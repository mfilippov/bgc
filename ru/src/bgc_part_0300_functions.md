<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# Функции {#functions}

> _"Сэр, не в такой среде как эта. Именно поэтому я также был
> запрограммирован на более чем тридцать вспомогательных функций, которые ---"_
>
> ---C3PO[i[C3PO]], до того как его грубо прервали, перечисляя
> теперь не-впечатляющее количество дополнительных функций, сценарий _Star Wars_

[i[Functions]<]
Так же как и во многих других языках, которые вам уже знакомы, в C есть понятие
_функций_.

Функции могут принимать различные _аргументы_[i[Function arguments]] и
возвращать значение. Однако важно помнить: типы аргументов и возвращаемого
значения заранее объявлены --- так уж в C принято!

Давайте посмотрим на функцию. Это функция, которая принимает `int`
в качестве аргумента и возвращает[i[`return` statement]] `int`.

``` {.c .numberLines}
#include <stdio.h>

int plus_one(int n)  // "определение"
{
    return n + 1;
}
 
```

`int` перед `plus_one` указывает тип возвращаемого значения.

`int n` указывает, что эта функция принимает один аргумент типа `int`,
который хранится в _параметре_ `n`[i[Function parameters]]. Параметр -
это специальный тип локальной переменной, в которую копируются аргументы.

Я хочу ещё раз подчеркнуть, что аргументы копируются в параметры.
Многое в C становится понятнее, если помнить, что параметр - это _копия_
аргумента, а не сам аргумент. Подробнее об этом чуть позже.

Продолжим разбор программы и спустимся в `main()`,
мы видим вызов функции, где возвращаемое значение присваивается
локальной переменной `j`:

``` {.c .numberLines startFrom="8"}
int main(void)
{
    int i = 10, j;
    
    j = plus_one(i);  // "вызов"

    printf("i + 1 is %d\n", j);
}
```

> Перед тем как я забуду, обратите внимание, что я определил функцию
> до её использования. Если бы я этого не сделал, компилятор ещё не знал бы
> о ней во время компиляции `main()` и выдал бы ошибку неизвестного вызова
> функции. Существует более правильный способ организации такого кода -
> с помощью _прототипов функций_, но об этом мы поговорим позже.

Также обратите внимание, что `main()`[i[`main()` function]] - это функция!

Она возвращает `int`.

Но что означает `void`[i[`void` type]]? Это ключевое слово, которое
указывает, что функция не принимает аргументов.

Вы также можете возвращать `void`, чтобы указать, что функция ничего не возвращает:

``` {.c .numberLines}
#include <stdio.h>

// Эта функция не принимает аргументов и не возвращает значения:

void hello(void)
{
    printf("Hello, world!\n");
}

int main(void)
{
    hello();  // Печатает "Hello, world!"
}
```

## Передача по значению {#passvalue}

[i[Pass by value]()]Ранее я упоминал, что когда вы передаёте аргумент
в функцию, создаётся копия этого аргумента и сохраняется в соответствующем
параметре.

Если аргумент - это переменная, копируется значение этой переменной и
помещается в параметр.

Более общо: всё выражение аргумента вычисляется, определяется его значение,
и это значение копируется в параметр.

В любом случае значение в параметре - это отдельная сущность. Оно
независимо от тех значений или переменных, которые вы использовали в качестве
аргументов при вызове функции.

Рассмотрим пример. Изучите его и попробуйте предсказать вывод до запуска:

``` {.c .numberLines}
#include <stdio.h>

void increment(int a)
{
    a++;
}

int main(void)
{
    int i = 10;

    increment(i);

    printf("i == %d\n", i);  // Что это выведет?
}
```

На первый взгляд кажется, что `i` равно `10`, мы передаём его в
функцию `increment()`. Там значение увеличивается, значит при выводе
оно должно быть `11`, верно?

> _"Привыкайте к разочарованию."_
>
> ---Ужасный Пират Робертс, _Принцесса-невеста_

Но на самом деле не `11` --- программа выводит `10`. Почему?

Дело в том, что выражения, которые вы передаёте функциям, _копируются_
в их соответствующие параметры. Параметр - это копия, а не оригинал.

Итак, `i` равно `10` в `main()`. Мы передаём его в `increment()`. Соответствующий
параметр в той функции называется `a`.

Копирование происходит как-бы присваиванием. Вольно говоря, `a = i`.
В тот момент `a` равно `10`. И в `main()` `i` тоже равно `10`.

Затем мы увеличиваем `a` до `11`. Но мы не трогаем `i`! Оно остаётся `10`.

Наконец, функция завершается. Все её локальные переменные удаляются
(прощай, `a`!) и мы возвращаемся в `main()`, где `i` по-прежнему `10`.

Мы выводим `i` - получаем `10` - и готово.

Именно поэтому, в предыдущем примере с `plus_one()` мы `return`(вернули)
локально изменённое значение, чтобы увидеть его снова в `main()`.

Звучит немного ограниченно, не правда ли? Создаётся впечатление, что
вы можете получить из функции только одно значение. Однако есть другой
способ вернуть данные; программисты на C называют его _передача по ссылке_,
и об этом мы расскажем в другой раз.

Но никакое пафосное название не должно отвлекать от факта, что
_ВСЁ_, что вы передаёте функции _БЕЗ ИСКЛЮЧЕНИЯ_, копируется в
соответствующий параметр, и функция оперирует этой локальной копией,
_НЕЗАВИСИМО_ от обстоятельств. Запомните это, даже когда будем говорить
о так называемой передаче по ссылке.
[i[Pass by value]>]

## Прототипы функций {#prototypes}

[i[Function prototypes]<]Если вы помните из предыдущих разделов, я
упоминал, что нужно определить функцию до её использования, иначе
компилятор не будет знать о ней заранее и выдаст ошибку.

Это не совсем строго так. Вы можете заранее сообщить компилятору, что
будете использовать функцию определённого типа с определённым списком
параметров. Тогда функцию можно определить где угодно (даже в другом
файле), при условии, что _прототип функции_ был объявлен до места её вызова.

К счастью, прототип функции очень прост. Это всего лишь копия первой
строки определения функции с точкой с запятой в конце. Например, в
этом коде вызывается функция, определённая позже, потому что сначала
объявлен её прототип:

``` {.c .numberLines}
#include <stdio.h>

int foo(void);  // Это - прототип!

int main(void)
{
    int i;
    
    // Мы можем вызвать foo() здесь до её определения, потому что
    // прототип уже объявлен выше!

    i = foo();
    
    printf("%d\n", i);  // 3490
}

int foo(void)  // Это - определение, точно как в прототипе!
{
    return 3490;
}
```

Если вы не объявляете функцию до её использования (ни через прототип,
ни через определение), вы фактически совершаете так называемое
_неявное объявление_[i[Implicit declaration]]. Оно допускалось в
первом стандарте C (C89), и в нем были правила относительно этого,
но сегодня такое уже не разрешено. Нет никаких законных причин
опираться на это в новом коде.

Вы могли заметить одну деталь в примерах, которые мы использовали...
А именно то, что мы пользовались старым добрым `printf()` без его
определения или объявления прототипа! Как нам это удалось? На самом деле
ничего странного - прототип есть; он находится в заголовочном файле
`stdio.h`, который мы подключили через `#include`, помните? Так что
мы по-прежнему чисты с точки зрения компилятора, офицер![i[Function prototypes]>]

## Пустые списки параметров

[i[Empty parameter lists]]
Вы можете встретить их в старом коде, но в новом писать так не следует.
Всегда используйте `void`[i[`void` type]] чтобы явно указать, что функция
не принимает параметров. Нет^[Никогда не говори "никогда".] причин
пропускать это в современном коде.

Если вы привыкли всегда ставить `void` для пустых списков параметров в
функциях и прототипах, можете забыть про остальную часть этого раздела.

Здесь есть два контекста:

* Пропуск всех параметров в определении функции
* Пропуск всех параметров в прототипе

Рассмотрим сначала возможное определение функции:

``` {.c}
void foo()  // Здесь на самом деле должен быть `void`
{
    printf("Hello, world!\n");
}
```

Хотя спецификация говорит, что поведение в этом случае эквивалентно тому,
как будто вы указали `void` (C11 §6.7.6.3¶14), тип `void` существует не
случайно. Используйте его.

Но в случае прототипа функции есть _существенная_ разница между
использованием `void`[i[`void` type-->in function prototypes]]
и его отсутствием:

``` {.c}
void foo();
void foo(void);  // Не то же самое!
```

Отсутствие `void` в прототипе сообщает компилятору, что у нас нет
дополнительной информации о параметрах функции. Это фактически
отключает проверку типов.

При наличии прототипа **обязательно** используйте `void`, если список
параметров пуст.

[i[Functions]>]
