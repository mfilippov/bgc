<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# Массивы {#arrays}

> _"Стоит ли начинать индексацию массивов с 0 или с 1? Мой компромисс
> в виде 0.5 отклонили без, как я считаю, должного рассмотрения."_
>
> ---Стэн Келли-Бутл, учёный в области информатики

[i[Arrays]<]
К счастью, в C есть массивы. Понимаю, язык считают
низкоуровневым^[Во всяком случае, в наши дни.], но в нём хотя бы
встроена концепция массивов. И поскольку множество языков позаимствовали
синтаксис у C, вы, вероятно, уже привыкли объявлять и использовать
массивы с помощью `[` и `]`.

Но в C массивы есть лишь _самую малость_! Как мы позже увидим, массивы
всего лишь синтаксический сахар---в глубине души, это указатели и всякое
подобное. _Паника!_ Но пока давайте просто пользоваться ими как
массивами. _Уф_.

## Простой пример

Давайте сразу посмотрим на пример:

[i[Arrays-->indexing]<]
``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    float f[4];  // Объявляем массив из 4 чисел с плавающей точкой

    f[0] = 3.14159;  // Индексация, разумеется, начинается с 0.
    f[1] = 1.41421;
    f[2] = 1.61803;
    f[3] = 2.71828;

    // Вывести их все:

    for (i = 0; i < 4; i++) {
        printf("%f\n", f[i]);
    }
}
```

При объявлении массива ему нужно задать размер. Размер должен быть
фиксированным^[Вернее, не совсем, но массивы переменной длины---которых
я не фанат---это тема для отдельного разговора.].

В примере выше мы создали массив из 4 значений `float`. Число в квадратных
скобках при объявлении именно это и показывает.

Позже мы обращаемся к элементам массива---для чтения или записи---снова
используя квадратные скобки.
[i[Arrays-->indexing]>]

Надеюсь, это выглядит знакомо по уже известным вам языкам!

## Получение длины массива

[i[Arrays-->getting the length]<]
Никак... ну почти. C не хранит эту информацию^[Поскольку под капотом
массивы представляют собой просто указатель на первый элемент, там нет
дополнительных сведений о длине.]. Её приходится хранить отдельно в
другой переменной.

Когда я говорю "никак", это означает, что есть ситуации, когда всё-таки
_можно_. Есть хитрость, позволяющая узнать количество элементов в массиве
в той области видимости, где этот массив объявлен. Но, вообще говоря,
если вы передадите массив функции, трюк не сработает^[Потому что при
передаче массива функции вы на самом деле передаёте указатель на первый
элемент, а не "весь" массив.].

Посмотрим на этот трюк. Основная идея: взять
[i[`sizeof` operator-->with arrays]<]`sizeof` массива и разделить на
размер одного элемента. Например, если `int` занимает 4 байта, а массив
занимает 32 байта, значит там помещается $\frac{32}{4}$, или $8$
элементов `int`.

``` {.c}
int x[12];  // 12 целых

printf("%zu\n", sizeof x);     // всего 48 байт
printf("%zu\n", sizeof(int));  // по 4 байта на int

printf("%zu\n", sizeof x / sizeof(int));  // 48/4 = 12 int!
```

Если это массив `char`, то `sizeof` массива _и есть_ количество
элементов, потому что `sizeof(char)` по определению равен 1. Для других
типов нужно делить на размер элемента.

Но этот трюк работает только в области видимости, где массив определён.
Если передать массив функции, ничего не выйдет. Даже если указать его
"большим" в сигнатуре:

``` {.c}
void foo(int x[12])
{
    printf("%zu\n", sizeof x);     // 8?! Где же 48?
    printf("%zu\n", sizeof(int));  // по 4 байта на int

    printf("%zu\n", sizeof x / sizeof(int));  // 8/4 = 2 int?? НЕВЕРНО.
}
```

Так происходит, потому что при "передаче" массива функциям мы передаём
только указатель на первый элемент, и именно его измеряет `sizeof`.
Подробнее об этом в разделе [Передача одномерных массивов
функциям](#passing1darrays).

Ещё один трюк с `sizeof`: можно узнать размер массива фиксированной
длины, даже не объявляя этот массив. Аналогично тому, как можно взять
размер `int` с помощью `sizeof(int)`.

Например, чтобы узнать, сколько байт потребуется для массива из 48
элементов типа `double`, можно написать:

``` {.c}
sizeof(double [48]);
```
[i[`sizeof` operator-->with arrays]>]
[i[Arrays-->getting the length]>]

## Инициализаторы массивов

[i[Array initializers]<]
Можно заранее проинициализировать массив константами:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};  // Инициализация этими значениями

    for (i = 0; i < 5; i++) {
        printf("%d\n", a[i]);
    }
}
```

Никогда не добавляйте в инициализатор больше элементов, чем помещается в
массив---компилятор будет ругаться:

``` {.zsh}
foo.c: In function ‘main’:
foo.c:6:39: warning: excess elements in array initializer
    6 |     int a[5] = {22, 37, 3490, 18, 95, 999};
      |                                       ^~~
foo.c:6:39: note: (near initialization for ‘a’)
```

Но (забавный факт!) элементов может быть _меньше_, чем размер массива.
Оставшиеся элементы автоматически инициализируются нулями. Это верно для
любых инициализаторов массивов: если инициализатор есть, всё, что не
получило значение явно, станет нулём.

``` {.c}
int a[5] = {22, 37, 3490};

// то же самое, что:

int a[5] = {22, 37, 3490, 0, 0};
```

Часто используют такой приём, чтобы заполнить массив нулями:

``` {.c}
int a[100] = {0};
```

Это значит: "Сделай первый элемент равным нулю, а остальные обнулятся
автоматически".

В инициализаторе можно присвоить значения конкретным элементам, указав
их индекс. Сделав это, C с радостью продолжит заполнять последующие
элементы, пока не закончится инициализатор, а остальные элементы
заполнит `0`.

Для этого поместите индекс в квадратные скобки, поставьте `=`, а после
него значение.

Вот пример построения массива:

``` {.c}
int a[10] = {0, 11, 22, [5]=55, 66, 77};
```

Поскольку мы указали индекс 5 началом для `55`, данные в массиве
получаются такими:

``` {.default}
0 11 22 0 0 55 66 77 0 0
```

Туда же можно вставлять простые константные выражения.

``` {.c}
#define COUNT 5

int a[COUNT] = {[COUNT-3]=3, 2, 1};
```

что даёт:

``` {.default}
0 0 3 2 1
```

Наконец, можно поручить C вычислить размер массива из инициализатора,
просто опустив размер:

``` {.c}
int a[3] = {22, 37, 3490};

// то же самое, что:

int a[] = {22, 37, 3490};  // Размер оставили пустым!
```
[i[Array initializers]>]

## За пределами массива!

[i[Arrays-->out of bounds]<]
C не мешает вам выйти за границы массива. Он даже может об этом не
предупредить.

Возьмём пример сверху и продолжим печатать элементы за пределами
массива. В нём всего 5 элементов, но попробуем вывести 10 и посмотрим,
что произойдёт:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};

    for (i = 0; i < 10; i++) {  // ПЛОХАЯ ИДЕЯ: выводим слишком много!
        printf("%d\n", a[i]);
    }
}
```

У меня программа выводит:

``` {.default}
22
37
3490
18
95
32765
1847052032
1780534144
-56487472
21890
```

Ужас! Что это было? Оказывается, выход за пределы массива приводит к
тому, что C-разработчики называют _неопределённым поведением_. Позже
мы поговорим об этом страшном звере подробнее, но пока это означает:
"Вы сделали что-то плохое, и в программе теперь может произойти всё что
угодно".

И под "всё что угодно" обычно подразумеваются нули, мусорные числа или
падение. Но стандарт C прямо говорит, что в такой ситуации компилятор
вправе сгенерировать код, который сделает _что угодно_^[В славные
MS-DOS-овские времена до появления защиты памяти я писал довольно
жестокий C-код, намеренно погружаясь в разные виды неопределённого
поведения. Я понимал, что делаю, и всё вроде шло неплохо. Пока я не
оступился, что привело к зависанию и, как выяснилось после перезагрузки,
к обнулению всех настроек BIOS. Весёлые времена. (Передаю особый привет
@man за те забавные дни.)].

Кратко: не делайте ничего, что вызывает неопределённое поведение.
Никогда^[Неопределённое поведение вызывает множество вещей, не только
выход за границы массива. Именно это делает язык C таким _захватывающим_.].
[i[Arrays-->out of bounds]>]

## Многомерные массивы

[i[Arrays-->multidimensional]<]
Можно добавить столько измерений, сколько душа пожелает.

``` {.c}
int a[10];
int b[2][7];
int c[4][5][6];
```

В памяти они хранятся в [flw[построчном
порядке|Row-_and_column-major_order]]. Это значит, что в двумерном
массиве первый индекс обозначает строку, а второй---столбец.

Инициализировать многомерные массивы можно, вкладывая инициализаторы
друг в друга:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int row, col;

    int a[2][5] = {      // Инициализируем двумерный массив
        {0, 1, 2, 3, 4},
        {5, 6, 7, 8, 9}
    };

    for (row = 0; row < 2; row++) {
        for (col = 0; col < 5; col++) {
            printf("(%d,%d) = %d\n", row, col, a[row][col]);
        }
    }
}
```

Вывод будет таким:

``` {.default}
(0,0) = 0
(0,1) = 1
(0,2) = 2
(0,3) = 3
(0,4) = 4
(1,0) = 5
(1,1) = 6
(1,2) = 7
(1,3) = 8
(1,4) = 9
```

Можно инициализировать массив явными индексами:

``` {.c}
// Создадим единичную матрицу 3x3

int a[3][3] = {[0][0]=1, [1][1]=1, [2][2]=1};
```

что создаёт двумерный массив вида:

``` {.default}
1 0 0
0 1 0
0 0 1
```
[i[Arrays-->multidimensional]>]

## Массивы и указатели

[i[Arrays-->as pointers]<]
[_Спокойствие_] Так... кажется, я упоминал выше, что массивы глубоко
внутри являются указателями? Самое время сделать неглубокое погружение,
чтобы не возникала полная путаница. Позже мы разберёмся, как именно
массивы связаны с указателями, а сейчас ограничимся передачей массивов
функциям.

### Получаем указатель на массив

Раскрою секрет: когда C-программист говорит "указатель на массив", чаще
всего он имеет в виду указатель _на первый элемент массива_^[Строго
говоря, указатель на массив и указатель на первый элемент имеют разные
типы. Но разберёмся с этим, когда придёт время.].

Давайте получим указатель на первый элемент массива.

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a[5] = {11, 22, 33, 44, 55};
    int *p;

    p = &a[0];  // p указывает на массив
                // Точнее, на первый элемент

    printf("%d\n", *p);  // Печатает "11"
}
```

В C это настолько распространено, что язык предлагает сокращение:

``` {.c .numberLines}
p = &a[0];  // p указывает на массив

// то же самое, что:

p = a;      // p указывает на массив, и выглядит куда приятнее!
```

Простая ссылка на имя массива эквивалентна получению указателя на
первый элемент! Мы будем активно использовать это в следующих примерах.

Но постойте-ка---`p` ведь `int*`? И `*p` даёт нам `11`, как `a[0]`? Да.
Вы начинаете видеть, насколько тесно массивы и указатели связаны в C.
[i[Arrays-->as pointers]>]

### Передача одномерных массивов функциям {#passing1darrays}

[i[Arrays-->passing to functions]<]
Сделаем пример с одномерным массивом. Напишем пару функций, которым
можно передавать массив, и они будут делать с ним различные вещи.

Приготовьтесь к умопомрачительным объявлениям функций!

``` {.c .numberLines}
#include <stdio.h>

// Передача указателя на первый элемент
void times2(int *a, int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 2);
}

// То же самое, но в виде массивной нотации
void times3(int a[], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 3);
}

// То же самое, но с массивной нотацией и размером
void times4(int a[5], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 4);
}

int main(void)
{
    int x[5] = {11, 22, 33, 44, 55};

    times2(x, 5);
    times3(x, 5);
    times4(x, 5);
}
```

Все эти способы указания массива в параметрах функции идентичны.

``` {.c}
void times2(int *a, int len)
void times3(int a[], int len)
void times4(int a[5], int len)
```

На практике чаще всего используют первый вариант.

И, более того, во втором и третьем случае компилятор даже не интересует,
какое именно число вы укажете (лишь бы оно было больше нуля^[C11
§6.7.6.2¶1 требует, чтобы оно было больше нуля. Тем не менее, вам может
встретиться код с массивами нулевой длины в конце `struct`, и GCC
относительно снисходителен к этому, пока не компилировать с опцией
`-pedantic`. Такой нулевой массив был хитрым способом делать структуры
переменной длины. К сожалению, доступ к нему формально приводит к
неопределённому поведению, даже если это, в общем-то, работало везде.
C99 закрепил корректную замену---так называемые _гибкие члены массива_,
о которых мы поговорим позже.]). Компилятор никак это не проверяет.

Теперь, когда я это сказал, отмечу: размер массива в объявлении функции
всё-таки _имеет значение_, когда речь идёт о передаче многомерных
массивов. Но об этом чуть позже.
[i[Arrays-->passing to functions]>]

### Изменение массивов в функциях

[i[Arrays-->modifying within functions]<]
Мы уже говорили, что массивы---это указатели под маской. Это значит, что
когда вы передаёте массив функции, скорее всего, вы передаёте указатель на
первый элемент массива.

А раз функция получает указатель на данные, она может эти данные
менять! Изменения, которые функция вносит в массив, будут видны
вызывающему коду.

Вот пример: мы передаём указатель на массив функции, функция меняет
значения элементов, и эти изменения видны после возврата.

``` {.c .numberLines}
#include <stdio.h>

void double_array(int *a, int len)
{
    // Умножить каждый элемент на 2
    //
    // Это удваивает значения x в main(), потому что x и a указывают
    // на один и тот же участок памяти!

    for (int i = 0; i < len; i++)
        a[i] *= 2;
}

int main(void)
{
    int x[5] = {1, 2, 3, 4, 5};

    double_array(x, 5);

    for (int i = 0; i < 5; i++)
        printf("%d\n", x[i]);  // 2, 4, 6, 8, 10!
}
```

Хотя мы передали массив в параметр `a` типа `int*`, обратите внимание,
что доступ к нему идёт через массивную нотацию `a[i]`! Вот это да. Так
можно.

Позже, когда обсудим эквивалентность массивов и указателей, всё станет
ещё понятнее. Пока достаточно знать, что функции способны вносить
изменения в массивы, и эти изменения видны снаружи.
[i[Arrays-->modifying within functions]>]

### Передача многомерных массивов функциям

[i[Arrays-->passing to functions]<]
С многомерными массивами история немного меняется. C нужно знать все
размерности (кроме первой), чтобы понимать, куда в памяти смотреть
за значением.

Вот пример, где мы явно указываем все размеры:

``` {.c .numberLines}
#include <stdio.h>

void print_2D_array(int a[2][3])
{
    for (int row = 0; row < 2; row++) {
        for (int col = 0; col < 3; col++)
            printf("%d ", a[row][col]);
        printf("\n");
    }
}

int main(void)
{
    int x[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    print_2D_array(x);
}
```

В данном случае эти две записи^[Есть ещё эквивалентный вариант:
`void print_2D_array(int (*a)[3])`, но вдаваться в него сейчас не будем.]
тождественны:

``` {.c}
void print_2D_array(int a[2][3])
void print_2D_array(int a[][3])
```

Компилятору на самом деле нужна только вторая размерность, чтобы понять,
какой шаг по памяти делать при увеличении первого индекса. Вообще ему
надо знать все размерности, кроме первой.

И не забывайте, что компилятор выполняет лишь минимальные проверки
границ на этапе компиляции (и то если повезёт), а на этапе выполнения C
не проверяет границы вообще. Никаких ремней безопасности! Не разбейтесь,
выйдя за пределы массива!
[i[Arrays-->passing to functions]>] [i[Arrays]>]
