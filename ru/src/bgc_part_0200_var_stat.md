<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# Переменные и операторы

> _"В мире есть место для всех, не так ли, падре?"_ \
> _"Да, сын мой, именно так."_
>
> ---Пиратский капитан Томас Бартоломью Ред, «Пираты»

В программе на C может быть очень много всего.

Ага.

И по ряду причин нам будет проще, если мы классифицируем
разные вещи, которые встречаются в программе, чтобы яснее понимать,
о чём идёт речь.

## Переменные

[i[Variables]<]Говорят, что "переменные хранят значения".
Но другой способ об этом думать - переменная это человеко-читаемое имя,
ссылающееся на данные в памяти.

Сейчас мы слегка заглянем в кроличью нору под названием "указатели".
Не переживайте.

Можно думать о памяти как о большом массиве байтов^["Байт" - это обычно
8-битное двоичное число. Представьте его как целое, способное хранить
значения от 0 до 255 включительно. Технически, стандарт C допускает байты
любой длины, и если вы хотите однозначно сказать "8-битное число",
лучше использовать термин _октет_. Но программисты по умолчанию понимают
под "байтом" именно 8 бит, если не уточнено иное.].
Данные сохраняются в этом "массиве"^[Я сильно упрощаю то, как реально
устроена современная память. Но как ментальная модель - работает,
так что простите.].
Если число больше одного байта, оно занимает несколько байтов.
Так как память устроена как массив, каждый байт можно найти по индексу.
Этот индекс ещё называют _адресом_, _расположением_ или _указателем_.

Когда у вас есть переменная в C, её значение хранится _где-то_ в памяти,
по какому-то адресу. Разумеется - где же ещё?
Но обращаться к значениям по числовым адресам неудобно,
поэтому мы даём имена - это и есть переменные.

Зачем я это всё рассказываю? По двум причинам:

1. Это поможет позже понять указатели---это переменные,
   которые хранят адреса других переменных!
2. И, кстати, это поможет вообще лучше понять указатели.

Итак, переменная - это имя для данных, которые хранятся в памяти по
какому-то адресу.

### Имена переменных

[i[Variables]<]Для имён переменных можно использовать любые символы
из диапазонов 0-9, A-Z, a-z и подчёркивание, с такими правилами:

* Нельзя начинать имя переменной с цифры 0-9.
* Нельзя начинать имя с двух подчёркиваний.
* Нельзя начинать имя с подчёркивания, за которым идёт заглавная буква A-Z.

Что касается Unicode - просто попробуйте. В спецификации есть правила
(см. §D.2), которые описывают, какие диапазоны кодпоинтов допустимы
в каких частях идентификаторов, но это слишком скучно, и вряд ли вам
когда-либо придётся думать об этом.[i[Variables]>]

### Типы переменных

[i[Types]]В зависимости от того, какие языки вы уже знаете,
понятие типов может быть для вас либо привычным, либо новым.
Но C довольно строг в этом, так что повторим.

Примеры простейших типов:

[i[`int` type]][i[`float` type]][i[`char` type]][i[`char *` type]]

|Тип|Пример|C-тип|
|:---|------:|:-----|
|Целое число|`3490`|`int`|
|Число с плавающей точкой|`3.14159`|`float`^[Немного слукавлю. Формально `3.14159` - это тип `double`. Но пока мы туда не полезем, я хочу, чтобы вы ассоциировали `float` с "floating point". Да и компилятор без проблем приведёт `double` к `float`. Так что до поры не заморачивайтесь.]|
|Символ (одиночный)|`'c'`|`char`|
|Строка|`"Hello, world!"`|`char *`^[Читайте как "указатель на char" или "char pointer". Char - это символ. По моим наблюдениям, большинство людей произносит это слово как «чар», меньшинство - как «кар», и совсем немногие - как «кэр». Позже поговорим подробнее про указатели.]|

C старается автоматически приводить большинство числовых типов.
Но в остальном преобразования ручные, особенно между строками и числами.

Почти все типы в C - вариации этих базовых.

Прежде чем использовать переменную, её нужно _объявить_ и сообщить C,
какой тип она хранит. После объявления тип менять нельзя.
Что установили - то и есть, пока переменная не выйдет из области видимости
и не растворится в бескрайней Вселенной.

Возьмём наш код "Hello, world" и добавим туда парочку переменных:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;    // Хранит целые числа со знаком, например: -3, -2, 0, 1, 10
    float f;  // Хранит числа с плавающей точкой со знаком, например: -3.1416

    printf("Hello, World!\n");  // Ах, блаженное знакомство
}
```

Вот так! Мы объявили пару переменных. Мы их пока не использовали,
и обе они неинициализированы. Одна хранит целое число,
а другая - число с плавающей точкой (по сути, вещественное число,
если вы знакомы с математикой).

[i[Variables-->uninitialized]]Неинициализированные переменные
имеют неопределённое значение^[В разговоре часто говорят,
что у них "случайное" значение, но это не настоящие
и даже не псевдослучайные - числа.].
Их необходимо инициализировать, иначе следует считать,
что в них хранится какой-то мусор.

> Вот одно из тех мест, где C может "подловить" вас.
> Очень часто, по моему опыту, неопределённое значение оказывается нулём...
> но это может меняться от запуска к запуску!
> Никогда не предполагайте, что значение будет равно нулю,
> даже если видите это. Всегда явно инициализируйте переменные
> каким-то значением перед использованием^[Это не совсем на 100% верно.
> Когда мы дойдём до переменных со статическим временем хранения,
> вы узнаете, что некоторые из них инициализируются нулём автоматически.
> Но безопаснее всегда инициализировать их явно.].

Что это? Вы хотите сохранить какие-то числа в этих переменных? Безумие!

Давайте сделаем это:
[i[`=` assignment operator]]

``` {.c .numberLines}
int main(void)
{
    int i;

    i = 2; // Присвоить значение 2 переменной i

    printf("Hello, World!\n");
}
```

Отлично. Мы сохранили значение. Давайте его выведем.

[i[`printf()` function]<]Сделаем это, передав _два_ чудесных аргумента
функции `printf()`. Первый аргумент - это строка, которая описывает,
что именно и как печатать (она называется _форматной строкой_),
а второй - это значение для вывода, то есть то, что хранится
в переменной `i`.

`printf()` просматривает форматную строку в поисках специальных
последовательностей, которые начинаются с символа процента (`%`)
и указывают, что именно нужно вывести. Например, встретив `%d`,
она берёт следующий переданный параметр и печатает его как целое число.
Если находит `%f` - выводит значение как число с плавающей точкой.
Если `%s` - выводит строку.

Таким образом, можно вывести значения разных типов вот так:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 2;
    float f = 3.14;
    char *s = "Hello, world!"; // char * («указатель на char») - это строковый тип

    printf("%s  i = %d and f = %f!\n", s, i, f);
}
```

И результат будет таким:

``` {.default}
Hello, world!  i = 2 and f = 3.14!
```

Таким образом, `printf()` может напоминать различные виды форматных строк
или параметризованных строк в других языках программирования,
с которыми вы уже знакомы.  [i[`printf()` function]>]

### Логические типы

[i[Boolean types]<]В C есть логические типы - истина или ложь?

`1`!

Исторически, в C не было логического типа, и некоторые могут сказать,
что его до сих пор "по-настоящему" нет.

В C число `0` означает "ложь", а любое ненулевое значение - "истина".

Так что `1` - это истина. И `-37` - это истина. А `0` - это ложь.

Вы можете объявлять логические переменные просто как int:

``` {.c}
int x = 1;

if (x) {
    printf("x is true!\n");
}
```

В стандарте C23 появились настоящие `bool`, `true` и `false`.
До этого, если у вас достаточно современная версия C, можно подключить
`#include <stdbool.h>`[i[`stdbool.h` header file]], чтобы получить то же самое:

``` {.c .numberLines}
#include <stdio.h>
#include <stdbool.h>  // не нужно в C23

int main(void) {
    bool x = true;

    if (x) {
        printf("x is true!\n");
    }
}
```

Формально, переменным типа `bool` следует задавать значения `true`,
`false` или результатом выражения, которое вычисляется в истину или ложь.
Но на самом деле к `bool` можно привести множество разных вещей.
Есть конкретные правила, но обычно "нулевые" значения становятся `false`,
а ненулевые - `true`.

Однако будьте осторожны: если зная, что численное значение `true` - это `1`,
скорее всего[^B1CA], вы рассчитываете на то, что какое-то другое
положительное значение будет восприниматься как `true`,
может получиться ошибка. Например:

``` {.c .numberLines}
printf("%d\n", true == 12);  // Выведет "0", т.е. false!
```

[^B1CA]: Технически, для представления `bool` используется
    всего один бит внутри `char`, так что он может быть либо нулём,
    либо единицей. Однако содержимое оставшихся (выравнивающих) битов
    `char` не определено. Для `false` это наверняка все нули.
    А вот для `true` я не уверен, что там тоже обязательно все нули.

## Операторы и выражения {#operators}

Операторы в C должны быть вам знакомы из других языков. Давайте быстро
пробежимся по некоторым из них.

(Деталей тут на самом деле гораздо больше, но в этом разделе мы рассмотрим
достаточно, чтобы начать работу.)

### Арифметические

[i[Arithmetic Operators]()]Надеюсь, эти операторы вам знакомы:
[i[`+` addition operator]] [i[`-` subtraction operator]]
[i[`*` multiplication operator]] [i[`/` division operator]]
[i[`%` modulus operator]]

``` {.c}
i = i + 3;  // Сложение (+) и присваивание (=), прибавить 3 к i
i = i - 8;  // Вычитание, вычесть 8 из i
i = i * 9;  // Умножение
i = i / 2;  // Деление
i = i % 5;  // Остаток от деления
```

Для всех этих операций есть сокращённые формы.
Каждую из строк выше можно записать короче:
[i[`+=` assignment operator]] [i[`-=` assignment operator]]
[i[`*=` assignment operator]] [i[`/=` assignment operator]]
[i[`%=` assignment operator]]

``` {.c}
i += 3;  // То же самое, что "i = i + 3", прибавить 3 к i
i -= 8;  // То же самое, что "i = i - 8"
i *= 9;  // То же самое, что "i = i * 9"
i /= 2;  // То же самое, что "i = i / 2"
i %= 5;  // То же самое, что "i = i % 5"
```

Возведения в степень в C нет. Для этого придётся использовать одну из функций
`pow()`[i[pow()]T] из `math.h`.

А теперь перейдём к более хитрым вещам, которых, возможно, нет в других языках!
[i[Arithmetic Operators]>]

### Тернарный оператор

[i[`?:` ternary operator]<]В C также есть _тернарный оператор_. Это выражение,
значение которого зависит от результата встроенного в него условия.

``` {.c}
// Если x > 10, прибавить к y число 17. Иначе прибавить 37.

y += x > 10? 17: 37;
```

Какой ужас! Но чем больше будете видеть такой код, тем привычнее он станет.
Чтобы было понятнее, перепишу его с использованием `if`:

``` {.c}
// Это выражение:

y += x > 10? 17: 37;

// эквивалентно этому коду без выражения:

if (x > 10)
    y += 17;
else
    y += 37;
```

Сравните эти два варианта, чтобы уловить каждую часть тернарного оператора.

Вот ещё пример - программа, которая печатает, чётное или нечётное число
хранится в `x`:

``` {.c}
printf("The number %d is %s.\n", x, x % 2 == 0? "even": "odd");
```

Форматный спецификатор `%s` в `printf()`[i[printf()]T] означает
"вывести строку". Если выражение `x % 2` вычисляется в `0`,
то всё тернарное выражение даёт строку "чётное".
В противном случае - строку "нечётное". Круто!

Важно отметить, что тернарный оператор - это не средство управления потоком,
как `if`. Это просто выражение, которое вычисляется в некоторое значение.
[i[`?:` ternary operator]>]

### Пре и пост инкремент/декремент

[i[`++` increment operator]<] [i[`--` decrement operator]<]
Теперь давайте разберём ещё одну штуку, которую вы, возможно,
раньше не встречали.

Это легендарные пост-инкремент и пост-декремент:

``` {.c}
i++;        // Прибавить 1 к i (пост-инкремент)
i--;        // Вычесть 1 из i (пост-декремент)
```

Очень часто они используются просто как короткая запись для:

``` {.c}
i += 1;        // Прибавить 1 к i
i -= 1;        // Вычесть 1 из i
```

но различия чуть изящнее, чем это видно сразу - такие уж они коварные штуки.

Теперь посмотрим на вариант с пре-инкрементом и пре-декрементом:

``` {.c}
++i;        // Прибавить 1 к i (пре-инкремент)
--i;        // Вычесть 1 из i (пре-декремент)
```

При пре-инкременте и пре-декременте значение переменной
увеличивается или уменьшается _до_ вычисления выражения.
Затем выражение вычисляется уже с новым значением.

При пост-инкременте и пост-декременте сначала вычисляется выражение
с текущим значением переменной, и только _после_ этого
значение увеличивается или уменьшается.

Их можно даже вставлять прямо в выражения, например так:

``` {.c}
i = 10;
j = 5 + i++;  // Сначала вычислить 5 + i, а потом увеличить i

printf("%d, %d\n", i, j);  // Выведет 11, 15
```

Сравним это с пре-инкрементом:

``` {.c}
i = 10;
j = 5 + ++i;  // Сначала увеличить i, а потом вычислить 5 + i

printf("%d, %d\n", i, j);  // Выведет 11, 16
```

Эта техника часто используется при работе с массивами и указателями.
Она даёт возможность и использовать значение переменной,
и одновременно увеличивать или уменьшать его до или после использования.

Но чаще всего вы увидите это в цикле `for`:

``` {.c}
for (i = 0; i < 10; i++)
    printf("i is %d\n", i);
```

Но об этом позже.
[i[`++` increment operator]>] [i[`--` decrement operator]>]

### Оператор запятая

[i[`,` comma operator]<]
Это редко используемый способ разделять выражения, которые выполняются
слева направо:

``` {.c}
x = 10, y = 20;  // Сначала присвоить 10 переменной x, затем 20 переменной y
```

Выглядит немного глупо, ведь можно было бы просто заменить запятую
на точку с запятой, правда?

``` {.c}
x = 10; y = 20;  // Сначала присвоить 10 переменной x, затем 20 переменной y
```

Но это чуть другое. Во втором случае - это два отдельных выражения,
а в первом - одно единственное выражение!

У оператора запятая значение всего выражения равно значению
самого правого операнда:

``` {.c}
x = (1, 2, 3);

printf("x is %d\n", x);  // Выведет 3, потому что 3 - крайнее справа в списке
```

Хотя и это выглядит натянуто. Обычное место применения оператора запятая -
циклы `for`, чтобы делать несколько действий в каждой части выражения:

``` {.c}
for (i = 0, j = 10; i < 100; i++, j++)
    printf("%d, %d\n", i, j);
```

Позже мы ещё вернёмся к этому.
[i[`,` comma operator]>]

### Условные операторы

[i[Conditional Operators]<]
Для сравнения значений у нас есть набор стандартных операторов:
[i[Comparison operators]] [i[`==` equality operator]]
[i[`!=` inequality operator]] [i[`<` less than operator]]
[i[`>` greater than operator]] [i[`<=` less or equal operator]]
[i[`>=` greater or equal operator]]

``` {.c}
a == b;  // Истина, если a равно b
a != b;  // Истина, если a не равно b
a < b;   // Истина, если a меньше b
a > b;   // Истина, если a больше b
a <= b;  // Истина, если a меньше или равно b
a >= b;  // Истина, если a больше или равно b
```

Не путайте присваивание (`=`) со сравнением (`==`)!
Для сравнения используйте два знака равенства, для присваивания - один.

Выражения сравнения можно использовать с условием `if`:

``` {.c}
if (a <= 10)
    printf("Success!\n");
```
[i[Conditional Operators]>]

### Логические (булевы) операторы

[i[Boolean Operators]<]
Мы можем связывать или изменять условные выражения с помощью булевых
операторов: _и_, _или_, и _не_.
[i[`&&` boolean AND]]
[i[`!` boolean NOT]]
[i[`||` boolean OR]]

|Operator|Boolean meaning|
|:------:|:-------------:|
|`&&`|and|
|`||`|or|
|`!`|not|

Пример булева "и":

``` {.c}
// Сделать что-то, если x меньше 10 и y больше 20:

if (x < 10 && y > 20)
    printf("Doing something!\n");
```

Пример булева "не":

``` {.c}
if (!(x < 12))
    printf("x is not less than 12\n");
```

У оператора `!` приоритет выше, чем у других булевых операторов,
поэтому в таких случаях нужно использовать скобки.


Конечно, это то же самое, что:

``` {.c}
if (x >= 12)
    printf("x is not less than 12\n");
```

но пример был нужен!
[i[Boolean Operators]>]

### Оператор `sizeof` {#sizeof-operator}

[i[`sizeof` operator]<]
Этот оператор сообщает, сколько байт в памяти занимает
переменная или тип данных.

Более точно, он показывает размер (в байтах), который занимает
_тип конкретного выражения_ (которое может быть просто одной переменной).

Это значение может различаться на разных системах, кроме `char`[i[`char`
type]] и его вариантов (они всегда занимают ровно 1 байт).

Сейчас это может показаться не очень полезным, но дальше мы будем
периодически к нему обращаться, так что стоит его разобрать.

Поскольку он вычисляет количество байт, нужных для хранения типа,
можно подумать, что результат будет `int`. Или... раз размер не может
быть отрицательным, может быть `unsigned`?

[i[`size_t` type]<]
На самом деле в C есть специальный тип для возвращаемого значения от `sizeof`.
Это `size_t`, произносится как "_сайз-ти_"^[Окончание `_t` - это сокращение
от `type`("тип").]. Всё, что мы знаем о нём - это беззнаковый целый тип,
который может хранить количество байт, нужное для любого выражения,
которое вы передадите в `sizeof`.

`size_t` часто встречается в местах, где передаётся или возвращается
количество чего-либо. Думайте о нём как о значении-счётчике.
[i[`size_t` type]>]

Можно взять `sizeof` от переменной или выражения:

``` {.c}
int a = 999;

// %zu это спецификатор формата для типа size_t
// Если компилятор ругается на букву "z", уберите её

printf("%zu\n", sizeof a);      // На моей системе печатает 4
printf("%zu\n", sizeof(2 + 7)); // На моей системе печатает 4
printf("%zu\n", sizeof 3.14);   // На моей системе печатает 8

// Если нужно вывести отрицательное значение типа size_t, используйте %zd
```

Помните: это размер в байтах _типа_ выражения, а не самого выражения.
Поэтому размер `2+7` совпадает с размером `a`---оба имеют тип `int`.
К числу `4` мы вернёмся в следующем примере...

...Где увидим, что можно брать `sizeof` от типа (и здесь
обязательно нужны скобки вокруг имени типа, в отличие от выражения):

``` {.c}
printf("%zu\n", sizeof(int));   // На моей системе печатает 4
printf("%zu\n", sizeof(char));  // На всех системах печатает 1
```

Важно отметить, что `sizeof` - это операция _времени компиляции_
^[Кроме массивов переменной длины - но это уже другая история.].
Результат полностью определяется во время компиляции, а не во время выполнения.

Позже мы этим воспользуемся.
[i[`sizeof` operator]>]


## Управление потоком исполнения

[i[Flow Control]<]
Булевы значения - это хорошо, но без управления потоком выполнения
программы мы никуда. Давайте посмотрим на несколько конструкций: `if`, `for`,
`while`, и `do-while`.

Сначала общее примечание от дружелюбного C-разработчика
про операторы и блоки операторов:

После таких конструкций, как `if` или `while`, можно поставить либо
один оператор для выполнения, либо блок операторов, которые будут
выполнены последовательно.

[i[`if` statement]<]
Начнём с одного оператора:

``` {.c}
if (x == 10) printf("x is 10\n");
```

Иногда это пишут и на отдельной строке. (Пробелы в целом не важны С---
это не Python.)

``` {.c}
if (x == 10)
    printf("x is 10\n");
```

А что если нужно, чтобы по условию выполнялось несколько действий?
Для этого можно использовать фигурные скобки, чтобы обозначить
_блок_ или _составной оператор_.

``` {.c}
if (x == 10) {
    printf("x is 10\n");
    printf("And also this happens when x is 10\n");
}
```

Очень распространённый стиль - _всегда_ использовать фигурные скобки,
даже если они не обязательны:

``` {.c}
if (x == 10) {
    printf("x is 10\n");
}
```

Некоторые разработчики считают, что так код читается проще
и помогает избежать ошибок вроде этой, когда визуально кажется,
что оператор внутри `if`, но на самом деле это не так:

``` {.c}
// ПЛОХОЙ ПРИМЕР

if (x == 10)
    printf("This happens if x is 10\n");
    printf("This happens ALWAYS\n");  // Сюрприз!! Безусловно!
```

`while` и `for` и другие циклы работают по тем же правилам,
что и в примерах выше. Если нужно выполнить несколько действий
внутри цикла или после `if`, заключайте их в фигурные скобки.

Иными словами, `if` запускает один оператор после себя.
И этим оператором может быть как одиночный оператор, так и блок.
[i[`if` statement]>]

### Оператор `if`-`else` {#ifstat}

[i[`if`-`else` statement]<]
Мы уже не раз использовали `if` в примерах - скорее всего,
вы видели его и в других языках. Но вот ещё один пример:

``` {.c}
int i = 10;

if (i > 10) {
    printf("Yes, i is greater than 10.\n");
    printf("And this will also print if i is greater than 10.\n");
}

if (i <= 10) printf("i is less than or equal to 10.\n");
```

В приведённом примере сообщение будет напечатано, если `i` больше 10;
в противном случае выполнение продолжается со следующей строки.
Обратите внимание на фигурные скобки после оператора `if`:
если условие истинно, выполняется либо первое выражение или оператор
сразу после `if`, либо весь блок кода в фигурных скобках.
Такое поведение _блока кода_ характерно для всех операторов.

Конечно, ведь C устроен таким забавным образом,
вы можете выполнить какое-то действие, если условие ложно,
с помощью `else`, добавленного к вашему `if`:

``` {.c}
int i = 99;

if (i == 10)
    printf("i is 10!\n");
else {
    printf("i is decidedly not 10.\n");
    printf("Which irritates me a little, frankly.\n");
}
```

И можно даже выстраивать их в цепочку,
чтобы проверить несколько разных условий, вот так:

``` {.c}
int i = 99;

if (i == 10)
    printf("i is 10!\n");

else if (i == 20)
    printf("i is 20!\n");

else if (i == 99) {
    printf("i is 99! My favorite\n");
    printf("I can't tell you how happy I am.\n");
    printf("Really.\n");
}
    
else
    printf("i is some crazy number I've never heard of.\n");
```

Если вы пойдёте по этому пути, обязательно посмотрите на оператор
[`switch`](#switch-statement) возможно, это будет лучшее решение.
Однако есть нюанс: `switch` работает только с проверкой на равенство
с константными числами. А вот приведённая выше цепочка `if`-`else`
может проверять неравенства, диапазоны, переменные и всё, что угодно,
что вы способны выразить в условии.
[i[`if`-`else` statement]>]