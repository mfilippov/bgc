<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# Привет, мир!

## Чего ожидать от C

> *«Куда ведет эта лестница?»* \
>
> *"Вверх."*
>
> ---Рэй Станц и Питер Венкман, Охотники за привидениями

C - это низкоуровневый язык.

Так было не всегда. В те времена, когда люди высекали перфокарты на граните,
C казался потрясающим способом избавиться от рутины низкоуровневых языков,
вроде [flw[assembly|Assembly_language]].

Но теперь, в наши времена, современные языки предлагают массу возможностей,
которых просто не существовало в 1972 году, когда появился C.
Это значит, что сам по себе C довольно простой язык, без обилия фич.
Он способен делать _всё_, но за это придётся попотеть.

Так зачем же нам вообще использовать его сегодня?

* Как инструмент обучения: C - это не только почтенный кусок истории
  вычислительной техники, но и язык, связанный с [flw[bare metal|Bare_machine]]
  так, как современные языки уже не связаны. Изучая C, вы узнаёте,
  как программы взаимодействуют с памятью компьютера на низком уровне.
  Здесь нет ремней безопасности. Ваши программы будут падать - уверяю вас.
  И это часть веселья!

* Как полезный инструмент: C до сих пор используется в ряде областей,
  например, при создании [flw[operating systems|Operating_system]]
  или во [flw[embedded systems|Embedded_system]].
  (Хотя язык [flw[Rust|Rust_(programming_language)]]
  уже поглядывает в обе эти стороны!)

Если вы знакомы с другим языком, многое в C покажется простым.
C вдохновил массу других языков, и вы встретите его отголоски в Go,
Rust, Swift, Python, JavaScript, Java и во множестве других.
Эти части будут вам знакомы.

Единственное, что в C сбивает людей с толку - это _указатели_.
Практически всё остальное выглядит знакомо, но указатели - штука странная.
Саму идею указателей вы, скорее всего, уже знаете, но C заставляет
работать с ней явно, используя операторы, которых вы, вероятно,
раньше не встречали.

Хитрость в том, что как только вы [flw[*грокните*|Grok]] указатели,
работать с ними станет легко. Но до этого они ускользают, как скользкие угри.

Всё остальное в C - это просто запомнить ещё один (а иногда и тот же самый!)
способ сделать то, что вы уже делали раньше.
Указатели - единственная странность. И даже они, по сути,
всего лишь вариация на тему, с которой вы, скорее всего, уже знакомы.

Так что приготовьтесь к увлекательному приключению - настолько близкому
к самому сердцу компьютера, насколько только можно подойти без ассемблера,
на самом влиятельном языке программирования всех времён
^[Знаю, найдутся те, кто поспорит, но хотя бы в тройку лидеров 
он точно входит, верно?]. Держитесь крепче!

## Привет, мир!

[i[Hello, world]()] Это канонический пример программы на C.
Его используют все. (Обратите внимание: цифры слева приведены
только для удобства чтения и не являются частью исходного кода.)

``` {.c .numberLines}
/* Hello world program */

#include <stdio.h>

int main(void)
{
    printf("Hello, World!\n");  // Actually do the work here
}
```

Мы наденем длинные резиновые перчатки, возьмём скальпель и вскроем эту штуку,
чтобы понять, как она устроена. Так что - готовьтесь к операции,
потому что мы начинаем. Разрезаем очень осторожно...

[i[Comments]<]

Начнём с самого простого: всё, что находится между символами `/*` и `*/`
- это комментарий, и компилятор полностью его игнорирует.
То же самое касается всего, что идёт в строке после `//`.
Комментарии позволяют оставлять себе и другим заметки,
чтобы когда вы вернётесь к коду в далёком будущем, вы смогли понять,
что же именно пытались сделать. Поверьте, вы забудете - это случается.

[i[Comments]>]

[i[C Preprocessor]<]
[i[`#include` directive]<]

А что это за `#include`? Фу! На самом деле он говорит препроцессору C
взять содержимое другого файла и вставить его прямо _сюда_.

Погодите-ка… а что такое препроцессор C? Отличный вопрос.
Процесс компиляции делится на две стадии
^[Ну, строго говоря, стадий больше двух, но давайте притворимся,
что их две - неведение тоже бывает счастьем, верно?]:
препроцессор и сам компилятор. [i[Octothorpe]] Всё, что начинается с решётки,
или "octothorpe" (`#`), обрабатывается препроцессором [i[Preprocessor]]
ещё до того, как за работу возьмётся компилятор.
Типичные _директивы препроцессора_, как их называют,
- это `#include` и `#define`.[i[`#define` directive]]
Об этом ещё поговорим.[i[`#include` directive]>][i[C Preprocessor]>]

Прежде чем мы продолжим: зачем мне вообще упоминать,
что знак решётки называется "octothorpe"? Ответ прост:
я считаю слово "octothorpe" до безобразия смешным и стараюсь везде его пихать,
как только появляется возможность.
Octothorpe. Octothorpe, octothorpe, octothorpe.

Ну _ладно_. После того как препроцессор C закончит всю свою работу,
результаты передаются компилятору, который уже превращает их в
[flw[assembly code|Assembly_language]], [flw[machine code|Machine_code]],
или что-то в этом духе. Машинный код - это "язык",
который понимает сам процессор, и понимает он его _очень быстро_.
Это одна из причин, почему программы на C обычно работают так шустро.

Не переживайте пока о технических деталях компиляции; просто знайте,
что ваш исходный код проходит через препроцессор,
затем результат отправляется компилятору, а тот уже создаёт исполняемый файл,
который можно запускать.

А что насчёт остальной части строки? [i[`stdio.h` header file]<]
Что такое`<stdio.h>`? Это так называемый _заголовочный файл_.
Точка-h в конце сразу выдаёт его. На самом деле это заголовочный файл
"Standard I/O" (`stdio`), который вы вскоре узнаете и полюбите.
Он даёт доступ ко множеству функций ввода-вывода
^[Технически говоря, он содержит директивы препроцессора и прототипы функций
(подробнее об этом позже) для стандартных задач ввода-вывода.].
В нашей демонстрационной программе мы выводим строку "Hello, World!",
и для этого нам нужна [i[`printf()` function]<] функция `printf()`.
Файл `<stdio.h>` предоставляет нам этот доступ.
По сути, если бы мы попытались использовать `printf()` без
`#include <stdio.h>`, компилятор бы нам на это пожаловался.

А как я узнал, что для `printf()` нужно написать `#include <stdio.h>`?
[i[`printf()` function]>] Ответ простой: это есть в документации.
Если вы работаете в Unix-системе, наберите `man 3 printf`
- и прямо в начале man-страницы будет указано,
какие заголовочные файлы нужны.
Или смотрите справочный раздел в этой книге. `:-)` [i[`stdio.h` header file]>]

Святые угодники! Всё это было ради первой строки!
Но давайте признаем - мы её полностью препарировали. Никаких тайн не осталось!

Так что сделайте паузу... ещё раз взгляните на пример кода.
Осталось всего пара лёгких строк.

Ну что, с возвращением после перерыва! Хотя я-то понимаю,
что вы его не сделали - я просто пошутил.

[i[`main()` function]<] Следующая строка — это `main()`.
Это определение функции `main()`; всё, что находится между фигурными скобками
(`{` и `}`), является частью этого определения.

(А как вообще _вызывать_ другую функцию?
Ответ скрывается в строке с `printf()`, но до этого мы ещё дойдём.)

Теперь о функции main: она особенная во многих отношениях,
но главное - именно она вызывается автоматически при запуске вашей программы.
Ничто из вашего кода не будет вызвано до `main()`.
В нашем примере это идеально подходит, потому что всё,
что нам нужно, - это напечатать строку и завершить работу.

Ах да, ещё один момент: когда программа дойдёт до конца `main()`,
до той самой закрывающей фигурной скобки, она завершится,
и вы снова окажетесь в командной строке.

Итак, теперь мы знаем, что программа подключила заголовочный файл
`stdio.h`[i[stdio.h]T] и объявила функцию `main()`,
которая будет выполняться при запуске программы.
А что же интересного скрывается внутри `main()`[i[`main()` function]>]?

Я так рад, что вы спросили. Честно! У нас там всего один “бонус” 
- вызов функции [i[`printf()` function]<]`printf()`.
Определить, что это именно вызов функции, а не её определение,
можно по ряду признаков, и один из них - отсутствие фигурных скобок после неё.
Кроме того, вызов функции заканчивается точкой с запятой,
чтобы компилятор понял: выражение завершено.
Привыкайте - ставить точки с запятой вам придётся почти везде,
как вы скоро увидите.

Вы передаёте один аргумент функции `printf()`[i[`printf()`
function]>]: строку, которую нужно напечатать при вызове.
Ах да — мы вызываем функцию! Мы крутые! Подождите, подождите...
не зазнавайтесь. [i[`\n`newline]<] А что это за странный `\n` в конце строки?
Дело в том, что большинство символов строки печатаются так,
как они хранятся. Но есть специальные символы,
которые напрямую вывести на экран не получится,
и они записываются как двухсимвольные коды с обратной косой чертой.
Один из самых популярных - `\n` (читается как "backslash-N"
или просто "newline"), который соответствует символу _новой строки_.
Именно он заставляет вывод продолжиться с начала следующей строки,
а не текущей. Это как нажать Enter в конце строки.[i[`\n` newline]>]

Теперь скопируйте этот код в файл с именем `hello.c` и соберите его.
На Unix-подобной платформе (например, Linux, BSD, Mac или WSL)
в командной строке сборка будет выглядеть примерно так:

[i[`gcc` compiler]]
``` {.zsh}
gcc -o hello hello.c
```

(Это значит: "скомпилировать `hello.c` и получить исполняемый файл
 с именем `hello`".)`

После этого у вас должен появиться файл с именем `hello`,
который можно запустить командой:

``` {.default}
./hello
```

(Префикс `./` говорит оболочке: "запусти из текущего каталога".)

И посмотрите, что получится:

``` {.default}
Hello, World! 
```

Готово и проверено! Можно выпускать![i[Hello, world]>]

## Подробности компиляции

[i[Compilation]<]Давайте чуть подробнее поговорим о том,
как собираются программы на C и что при этом происходит "за кулисами".

Как и у других языков, у C есть _исходный код_.
Но, в зависимости от того, с каким языком вы имели дело раньше, вам,
возможно, никогда не приходилось _компилировать_ свой исходный код
в _исполняемый файл_.

Компиляция - это процесс превращения исходного кода на C в программу,
которую может выполнить ваша операционная система.

Разработчики на JavaScript и Python вообще не привыкли к отдельному шагу
компиляции - хотя за кулисами он всё же есть!
Python компилирует ваш исходный код в так называемый _байт-код_,
который выполняет виртуальная машина Python.
Разработчики на Java к компиляции привыкли, но она там тоже выдаёт байт-код
для Java Virtual Machine.

При компиляции C генерируется _машинный код_. Это единицы и нули,
которые процессор может выполнять напрямую и очень быстро.

> Языки, которые обычно не компилируются, называются _интерпретируемыми_.
> Но, как мы уже упоминали в случае с Java и Python,
> у них тоже есть шаг компиляции. И нет правила, запрещающего интерпретацию C.
> (Такие интерпретаторы действительно существуют!)
> В общем, здесь всё не так чёрно-бело.
> Компиляция в целом - это просто преобразование исходного кода в другую,
> более удобную для выполнения форму.

Компилятор C - это программа, которая выполняет компиляцию.

Как мы уже говорили, `gcc` - это компилятор, который установлен во многих
[flw[Unix-подобных операционных системах|Unix]].
Обычно его запускают из командной строки в терминале,
но не всегда - вы можете запускать его и прямо из своей IDE.

Итак, как же собирать программы из командной строки?

## Сборка с `gcc`

[i[`gcc` compiler]<]Если у вас в текущем каталоге есть исходный файл
с именем `hello.c`, вы можете собрать из него программу под названием `hello`,
введя в терминале такую команду:

``` {.zsh}
gcc -o hello hello.c
```

Опция `-o` означает "вывести в этот файл"^[Если не указать имя выходного файла,
он по умолчанию будет называться `a.out` - это название уходит корнями глубоко
в историю Unix.]. А в конце команды указывается `hello.c`
- имя файла, который мы хотим скомпилировать.

Если ваш исходный код разбит на несколько файлов,
вы можете скомпилировать их все вместе (почти так, как если бы это был
один файл, хотя на самом деле правила немного сложнее),
указав все файлы с расширением `.c` в командной строке:

``` {.zsh}
gcc -o awesomegame ui.c characters.c npc.c items.c
```
[i[`gcc` compiler]>]

и они все соберутся вместе в один большой исполняемый файл.

Этого достаточно, чтобы начать - позже мы подробнее поговорим о работе
с несколькими исходными файлами, объектными файлами и всякими другими
интересными вещами.[i[Compilation]>]

## Сборка с `clang`

На Mac стандартным компилятором является не `gcc`,
а `clang`[i[`clang` compiler]]. Но вместе с ним устанавливается обёртка,
так что вы можете запускать `gcc`, и всё равно будет работать.

Вы также можете установить настоящий компилятор `gcc`[i[`gcc` compiler]]
через [fl[Homebrew|https://formulae.brew.sh/formula/gcc]] или другим способом.

## Сборка с помощью IDE

[i[Integrated Development Environment]<]Если вы используете
_интегрированную среду разработки_ (IDE), скорее всего,
вам не придётся собирать программу из командной строки.

В Visual Studio комбинация `CTRL-F7` выполняет сборку,
а `CTRL-F5` - запуск программы.

В VS Code можно нажать `F5`, чтобы запустить программу через отладчик.
(Но нужно установить расширение C/C++.)

В XCode можно собрать проект с помощью `COMMAND-B`,
а запустить - с помощью `COMMAND-R`.
Чтобы установить инструменты командной строки, просто загуглите
"XCode command line tools" - и вы найдёте инструкции по установке.

Для начала я советую вам попробовать собирать программы и из командной строки
- это часть истории![i[Integrated Development Environment]>]

## Версии C

[i[Language versions]<]C прошёл длинный путь за эти годы,
и у него было много пронумерованных версий, которые обозначают,
каким диалектом языка вы пользуетесь.

Они обычно ссылаются на год выхода спецификации.

Самые известные - это C89, C99, C11 и C23.
В этой книге мы сосредоточимся на последнем.

А вот более полный список в таблице:

|Версия|Описание|
|-----|--------------|
|K&R C|1978 - оригинальная версия. Названа в честь Брайана Кернигана и Денниса Ричи. Ричи разработал и реализовал язык, а Керниган был соавтором книги о нём. Сегодня исходный код в стиле K&R встретишь редко. Если встретите, он покажется странным - примерно как старинный английский современному читателю.|
|**C89**, ANSI C, C90|В 1989 году Американский национальный институт стандартов (ANSI) выпустил спецификацию языка C, которая задала направление развития C, сохраняющееся и поныне. Год спустя управление перешло к Международной организации по стандартизации (ISO), выпустившей идентичный стандарт C90.|
|C95|Редко упоминаемое дополнение к C89, в котором появилась поддержка широких символов.|
|**C99**|Первое крупное обновление с множеством новых возможностей языка. Больше всего людям запомнилось добавление комментариев в стиле `//`. Это самая популярная версия C на момент написания этой книги.|
|**C11**|В этом крупном обновлении языка появились поддержка Unicode и многопоточность. Имейте в виду: если вы начнёте использовать эти возможности, можете потерять переносимость в системах, которые застряли на уровне C99. Но, честно говоря, 1999-й был уже довольно давно.|
|C17, C18|Обновление C11 с исправлениями ошибок. Похоже, официальное название - C17, хотя публикация была отложена до 2018 года. Насколько я могу судить, эти две версии взаимозаменяемы, но предпочтительнее использовать C17.|
|C23|Последняя спецификация.|

[i[`gcc` compiler]<]Вы можете заставить GCC использовать
один из этих стандартов с помощью аргумента командной строки `-std=`.
А если хотите, чтобы он строже следил за стандартом, добавьте `-pedantic`.

Например:

``` {.zsh}
gcc -std=c11 -pedantic foo.c
```

Для этой книги я компилирую программы в стандарте C23
с включёнными всеми предупреждениями:

``` {.zsh}
gcc -Wall -Wextra -std=c23 -pedantic foo.c
```
[i[`gcc` compiler]>]
