<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
# Указатели --- трепещите! {#pointers}

> _"Как попасть в Карнеги-холл?"_ \
> _"Практика!"_
>
> ---шутка XX века неизвестного автора

[i[Pointers]<]Указатели --- одно из самых пугающих понятий языка C.
На деле именно они делают этот язык хоть сколько-нибудь сложным. Но
почему?

Потому что, если говорить честно, они могут вызвать электрический
разряд, который пробежит по клавиатуре и физически _приварит_ ваши руки
к столу, обрекая вас на вечную жизнь за клавиатурой этого языка из 70-х
годов!

Правда? Ну, не совсем. Я лишь пытаюсь настроить вас на успех.

В зависимости от того, из какого языка вы пришли, возможно, вы уже
знаете концепцию _ссылок_, когда переменная ссылается на объект
определённого типа.

Здесь всё примерно так же, только в C приходится явно говорить, идёт ли
речь о ссылке или о самом объекте, на который она указывает.


## Память и переменные {#ptmem}

Компьютерная память хранит любые данные, верно? Там живут и `float`,
и `int`, и что угодно ещё. Чтобы с этой памятью было проще работать,
каждый байт получает собственный целочисленный идентификатор. Эти
числа увеличиваются последовательно по мере продвижения по
памяти^[Обычно. Уверен, где-то в тёмных коридорах компьютерной истории
есть исключения.]. Можно представить её как набор пронумерованных
коробок, каждая из которых содержит байт^[Байт --- это число из не более
чем 8 двоичных разрядов, или _битов_. В десятичной системе, которой
пользовались ещё наши бабушки, оно вмещает беззнаковое значение от 0 до
255 включительно.] данных. Или как огромный массив, если вы пришли из
языка с массивами. Число, обозначающее каждую коробку, называется её
_адресом_[i[Memory address]].

Но не все типы данных занимают один байт. Например, `int` часто
потребляет четыре байта, как и `float`, но на самом деле всё зависит от
системы. Оператор `sizeof` поможет узнать, сколько байт памяти требуется
конкретному типу.

``` {.c}
// %zu --- спецификатор формата для типа size_t

printf("an int uses %zu bytes of memory\n", sizeof(int));

// У меня выводит "4", но на других системах значение может отличаться.
```

> **Занимательный факт о памяти**: когда у вас есть тип данных (например
> типичный `int`), который требует более одного байта памяти, байты,
> составляющие эти данные, всегда располагаются в памяти подряд. Иногда
> в ожидаемом порядке, а иногда и нет^[Порядок следования байтов
> называется _порядком байтов_ (endianness). Чаще всего встречаются
> _big-endian_ (с наиболее значимым байтом первым) и _little-endian_
> (с наиболее значимым байтом последним), а иногда, хоть и редко,
> _mixed-endian_ (с наиболее значимыми байтами где-то ещё).]. Хотя C
> ничего не гарантирует относительно конкретного порядка байтов (он
> зависит от платформы), обычно можно писать платформенно-независимый
> код так, чтобы вообще не задумываться об этих раздражающих порядках.

Итак, если можно, перейдём к определению указателя под торжественную
барабанную дробь и слегка зловещую музыку: _указатель --- это переменная,
которая хранит адрес_. Представьте, что прямо сейчас зазвучала
классическая тема из "2001: Космическая одиссея". Ба-бум ба-бум
ба-бум БАААА!

Ладно, возможно, я слегка перегнул. Никакой загадки в указателях нет.
Это просто адрес данных. Как переменная типа `int` может хранить значение
`12`, так и переменная-указатель может хранить адрес данных.

Это означает, что следующие слова обозначают одно и то же, а именно
число, указывающее на место в памяти:

* индекс в памяти (если вы воспринимаете память как огромный массив)
* адрес
* расположение

Я буду использовать их взаимозаменяемо. И да, я вставил слово
_расположение_, потому что никогда не бывает слишком много синонимов.

Переменная-указатель хранит это адресное число. Так же как переменная
`float` может хранить `3.14159`.

Представьте, что у вас есть куча стикеров Post-it®, все пронумерованы
по порядку своим адресом. (Первый имеет номер `0`, следующий --- `1` и
так далее.)

Помимо номера позиции, на каждый стикер можно записать ещё одно число.
Это может быть количество собак, которые у вас есть. Или число лун у
Марса...

...А может быть, _это будет индекс другого стикера!_

Если вы записали количество собак, это обычная переменная. Но если вы
записали индекс другого стикера, _это указатель_. Он указывает на тот
другой стикер!

Ещё одна аналогия --- с адресами домов. Дом может иметь определённые
характеристики: двор, металлическую крышу, солнечные панели и т. д. А
можно иметь адрес этого дома. Адрес --- это не сам дом. Дом --- это
полноценная постройка, а адрес --- всего лишь несколько строк текста.
Но адрес дома --- это _указатель_ на дом. Он не является домом сам по
себе, но говорит, где его найти.

То же самое можно сделать и с данными в компьютере. У вас может быть
переменная с некоторым значением. Это значение хранится в памяти по
какому-то адресу. И можно сделать отдельную _переменную-указатель_,
которая будет хранить адрес той переменной.

Это не сама переменная с данными, но, как и адрес дома, она сообщает,
где их найти.

Когда так происходит, мы говорим, что имеем "указатель на" эти данные.
Мы можем следовать по указателю, чтобы получить доступ к самим данным.

(Хотя пока это не кажется особенно полезным, без этого нельзя обойтись
при работе с функциями. Терпите, скоро дойдём.)

Допустим, у нас есть `int`, и мы хотим получить указатель на него. Нам
нужно каким-то образом получить адрес этого `int`, верно? Ведь указатель
просто хранит _адрес_ данных. Какой оператор позволит нам получить
_адрес_ `int`?

[i[`&` address-of operator]<]Ну что ж, к вашему, дорогой читатель,
невероятному удивлению, мы используем оператор `взятия адреса`
(это амперсанд "`&`"), чтобы получить адрес данных. Амперсанд.

В качестве короткого примера введём новый _спецификатор формата_ для
`printf()`, чтобы печатать указатели. Вы уже знаете, что `%d` выводит
целое число, да? Так вот, `%p`[i[`printf()` function-->with pointers]]
печатает указатель. Этот указатель будет выглядеть как какое-то
мусорное число (и, возможно, будет напечатан в шестнадцатеричном
виде^[То есть в системе счисления по основанию 16 с цифрами 0, 1, 2,
3, 4, 5, 6, 7, 8, 9, A, B, C, D, E и F.], а не в десятичном), но это
всего лишь индекс в памяти, где хранятся данные. (Или индекс байта, с
которого начинаются многобайтовые данные.) Практически во всех случаях,
включая этот, конкретное значение напечатанного числа вам неважно; я
показываю его исключительно ради демонстрации оператора взятия адреса.

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 10;

    printf("The value of i is %d\n", i);
    printf("And its address is %p\n", (void *)&i);
}
```

> **В приведённом коде есть _приведение типа_**, где мы принудительно
> заставляем выражение `&i` иметь тип `void*`. Так мы избавляемся от
> предупреждения компилятора. Мы этого ещё не проходили, поэтому пока
> просто игнорируйте `(void*)` в примере и делайте вид, что его там нет.

На моём компьютере программа выводит:

``` {.default}
The value of i is 10
And its address is 0x7ffddf7072a4
```
[i[`&` address-of operator]>]

Если интересно, это шестнадцатеричное число равно 140,727,326,896,068 в
десятичной системе (той самой, которой пользовалась ваша бабушка). Это
индекс в памяти, где хранятся данные переменной `i`. Это адрес `i`. Это
расположение `i`. Это указатель на `i`.

> **Подождите, да у вас же 140 терабайт ОЗУ?** Конечно! А у вас нет?
> Ладно, вру: конечно нет (по состоянию на 2024). Современные компьютеры
> используют чудо-технологию под названием
> [flw[виртуальная память|Virtual_memory]], из-за которой процессы думают,
> что обладают всем адресным пространством совместно, независимо от объёма
> физической памяти. Поэтому, даже если адрес огромный,
> виртуальная память процессора отображает его на какой-то
> более низкий физический адрес. На моём компьютере 16 ГБ ОЗУ
> (снова-таки, 2024 год, но я работаю под Linux, так
> что этого хватает). Терабайты ОЗУ? Да я преподаватель, а не
> дотком-богач. Нам обо всём этом волноваться не нужно, если не считать
> того факта, что я не баснословно богат.

Это указатель, потому что он говорит, где находится `i` в памяти. Как
домашний адрес на клочке бумаги подсказывает, где искать дом, так это
число показывает, где в памяти лежит значение `i`. Оно указывает на `i`.

Ещё раз: нам почти никогда не важно конкретное значение адреса. Главное,
что это указатель на `i`.

## Типы указателей {#pttypes}

[i[Pointer types]<]Что ж... это всё замечательно. Теперь вы умеете брать
адрес переменной и печатать его на экране. Отличный пункт для резюме,
верно? И вот вы хватаете меня за шиворот и вежливо спрашиваете, на кой
чёрт вам эти указатели нужны.

Прекрасный вопрос, и мы к нему вернёмся сразу после сообщения нашего
спонсора.

```
ACME СЛУЖБА РОБОТИЗИРОВАННОЙ УБОРКИ ЖИЛЫХ МОДУЛЕЙ. ВАША УСАДЬБА БУДЕТ
РАЗИТЕЛЬНО ПРЕОБРАЖЕНА, ИЛИ ВАС ЛИКВИДИРУЮТ. СООБЩЕНИЕ ОКОНЧЕНО.
```

Снова здравствуйте, это очередной выпуск "Beej's Guide". Мы остановились
на том, как же использовать указатели. Мы собираемся сохранить указатель
в переменной, чтобы применить его позже. Опознать _тип указателя_ можно
по звёздочке (`*`) перед именем переменной и после её типа:

``` {.c .numberLines}
int main(void)
{
    int i;  // тип i --- "int"
    int *p; // тип p --- "указатель на int", или "int-указатель"
}
```

Итак, у нас есть переменная, тип которой --- указатель, и она может
указывать на другие `int`. То есть хранить адреса других `int`. Мы знаем,
что он указывает на `int`, потому что имеет тип `int*` (читается как
"инт-указатель").

Когда вы присваиваете что-то переменной-указателю, тип правой части
выражения должен совпадать с типом указателя. К счастью, когда вы берёте
адрес переменной, результат имеет тип "указатель на тип этой
переменной", поэтому такие присваивания вполне корректны:

``` {.c}
int i;
int *p;  // p --- указатель, но пока не инициализирован и содержит мусор

p = &i;  // p получает адрес i --- теперь p "указывает" на i
```

Слева от оператора присваивания у нас переменная типа
"указатель-на-`int`" (`int*`), а справа --- выражение того же типа,
потому что `i` --- это `int` (а адрес `int` и даёт указатель на `int`).
Адрес объекта можно хранить в указателе на этот объект.

Понимаете? Пока всё это не слишком осмысленно, потому что мы ещё не
видели реального применения указателей, но мы идём маленькими шагами,
чтобы никто не потерялся. Пора познакомиться с оператором, противоположным
взятию адреса. Это как будто оператор `взятия адреса` попал в мир Бизарро.
[i[Pointer types]>]

## Разыменование {#deref}

[i[Dereferencing]<]Переменную-указатель можно представить как переменную,
которая _ссылается_ на другую переменную, указывая на неё. В мире C
редко говорят "ссылки" или "ссылается", но я упоминаю это, чтобы имя
оператора стало понятнее.

Когда у вас есть указатель на переменную (по сути "ссылка на
переменную"), вы можете работать с оригинальной переменной через
указатель, _разыменовывая_ его. (Можно думать об этом как о
"деуказателивании", хотя так никто не говорит.)

Возвращаясь к аналогии: это всё равно что посмотреть на адрес дома, а
затем поехать по нему прямо к дому.

Что я имею в виду под "получить доступ к оригинальной переменной"?
Если у вас есть переменная `i`, и есть указатель `p`, который на неё
указывает, вы можете использовать разыменованный `p` _точно так же,
как исходную переменную `i`_!

[i[`*` indirection operator]<]Вам почти хватает знаний для примера.
Последний штрих: что же такое оператор разыменования? Его ещё называют
_оператором непрямого обращения_, потому что вы получаете доступ к
значениям косвенно, через указатель. Это та же звёздочка `*`. Не путайте
её со звёздочкой, которую мы использовали в объявлении указателя выше.
Это один и тот же символ, но в разных контекстах он означает разное^[И
это ещё не всё! Он используется в `/*комментариях*/`, в умножении, а
ещё в прототипах функций с массивами переменной длины! Символ один, но
контекст меняет смысл.].

Вот полноценный пример:

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int *p;  // это НЕ разыменование --- это тип "int*"

    p = &i;  // теперь p указывает на i, p хранит адрес i

    i = 10;  // теперь i равен 10
    *p = 20; // объект, на который указывает p (а именно i!), теперь 20!!

    printf("i is %d\n", i);   // выводит "20"
    printf("i is %d\n", *p);  // тоже "20"! *p эквивалентен i!
}
```

Помните, что `p` хранит адрес `i`, как видно из присваивания `p` на
строке 8. Оператор непрямого обращения говорит компьютеру _использовать
объект, на который указывает указатель_, а не сам указатель. Таким
образом `*p` становится чем-то вроде псевдонима для `i`.[i[Dereferencing]>][i[`*` indirection operator]>]

Отлично, но _зачем_? Зачем всё это?

## Передача указателей в аргументах {#ptpass}

[i[Pointers-->as arguments]<]Сейчас вы думаете, что знаете об указателях
очень много, но применять это совершенно негде, верно? Ведь зачем писать
`*p`, если можно просто использовать `i`?

Друзья, настоящая мощь указателей раскрывается, когда вы начинаете
передавать указатели в функции. Почему это так важно? Вы, возможно, помните,
что аргументы функций копировались в параметры, и вы могли работать
с локальными копиями внутри функции, а затем возвращать одно-единственное
значение.

А что, если нужно вернуть больше одного значения из функции? Возвратом
можно вернуть только что-то одно, верно? Что если я отвечу на ваш вопрос
другим вопросом? ...Точнее, парочкой вопросов?

Что произойдёт, если передать указатель в качестве аргумента функции?
Скопируется ли указатель в соответствующий параметр? _Ещё бы!_
Помните, как раньше я до бесконечности повторял, что _КАЖДЫЙ АРГУМЕНТ_
копируется в параметр, и функция работает с копией? То же самое и здесь.
Функция получает копию указателя.

Но, и вот хитрость: мы заранее заставим указатель указывать на нужную
переменную... и функция сможет разыменовать свою копию указателя, чтобы
вернуться к исходной переменной! Сама переменная функции недоступна, но
она вполне может разыменовать указатель на неё!

Это похоже на ситуацию, когда вы записали адрес дома на листок бумаги,
а затем переписали его на другой листок. У вас теперь _два_ указателя
на этот дом, и оба одинаково хороши, чтобы добраться туда.

В случае вызова функции одна копия хранится в указателе во внешней
области видимости, а другая --- в параметре функции.

Пример! Давайте снова взглянем на функцию `increment()`, но на этот
раз заставим её действительно увеличивать значение в вызывающем коде.

``` {.c .numberLines}
#include <stdio.h>

void increment(int *p)  // обратите внимание: функция принимает указатель на int
{
    *p = *p + 1;        // прибавить единицу к объекту, на который указывает p
}

int main(void)
{
    int i = 10;
    int *j = &i;  // см. оператор взятия адреса: теперь это указатель на i

    printf("i is %d\n", i);        // выводит "10"
    printf("i is also %d\n", *j);  // выводит "10"

    increment(j);                  // j --- указатель типа int*, указывает на i

    printf("i is %d\n", i);        // выводит "11"!
}
```

Отлично! Здесь есть несколько моментов... в первую очередь то, что
`increment()` принимает `int*`. Мы передаём ей `int*` при вызове, когда
превращаем переменную `i` в указатель при помощи оператора `взятия адреса`.
(Помните: указатель хранит адрес, поэтому мы получаем указатель на
переменную, применяя к ней оператор `взятия адреса`.)

Функция `increment()` получает копию указателя. Оригинальный указатель
`j` (в `main()`) и его копия `p` (параметр в `increment()`) указывают на
один и тот же адрес, где хранится `i`. (По аналогии: два листка бумаги
с одним и тем же адресом.) Разыменовав любой из них, вы можете изменить
исходную переменную `i`! Функция способна изменить переменную в другой
области видимости! Да здравствует указательная магия!

Часто пример записи упрощают, вызывая функцию прямо с оператором взятия
адреса:

``` {.c}
printf("i is %d\n", i);  // выводит "10"
increment(&i);
printf("i is %d\n", i);  // выводит "11"!
```

Общее правило: если вы хотите, чтобы функция изменила переданный объект
так, чтобы вы увидели результат, нужно передавать указатель на этот
объект.

## Указатель `NULL`

[i[`NULL` pointer]<]Любую переменную-указатель любого типа можно
установить в специальное значение `NULL`. Это значит, что указатель ни
на что не указывает.

``` {.c}
int *p;

p = NULL;
```

Так как он ни на что не указывает, разыменование приводит к
неопределённому поведению и, скорее всего, к аварийному завершению:

``` {.c}
int *p = NULL;

*p = 12;  // ПАДЕНИЕ или что-то не менее ужасное. ЛУЧШЕ ЭТОГО НЕ ДЕЛАТЬ.
```

Несмотря на то, что создатель назвал его
[flw[ошибкой на миллиард долларов|Null_pointer#History]], указатель
`NULL` отлично работает как [flw[маркерное значение|Sentinel_value]]
и удобный индикатор того, что указатель ещё не инициализирован.

(Как и любые другие переменные, указатель будет содержать мусор, пока вы
явно не присвоите ему адрес или `NULL`.)[i[`NULL` pointer]>]

## Пара слов об объявлении указателей

[i[Pointers-->declarations]<]Синтаксис объявления указателя может быть
чуть странным. Посмотрим на пример:

``` {.c}
int a;
int b;
```

Мы можем объединить это в одну строку, верно?

``` {.c}
int a, b;  // то же самое
```

И `a`, и `b` --- тип `int`. Всё просто.

А что насчёт такого?

``` {.c}
int a;
int *p;
```

Можно ли записать это в одну строку? Да. Но куда поставить `*`?

Правило такое: `*` ставится перед каждой переменной, которая должна быть
указателем. То есть `*` --- это _не_ часть `int` в этом примере; это
часть переменной `p`.

С учётом этого можно написать так:

``` {.c}
int a, *p;  // то же самое
```

Важно не забывать, что следующая строка объявляет _не_ два указателя:

``` {.c}
int *p, q;  // p --- указатель на int; q --- просто int.
```

Это особенно коварно выглядит, если программист напишет следующую
(корректную) строку, которая на деле идентична предыдущей.

``` {.c}
int* p, q;  // p --- указатель на int; q --- просто int.
```

Попробуйте-ка определить, какие переменные в примере ниже являются
указателями, а какие нет:

``` {.c}
int *a, b, c, *d, e, *f, g, h, *i;
```

Ответ спрятан в сноске^[Переменные-указатели --- это `a`, `d`, `f` и `i`,
потому что перед ними стоит `*`.].[i[Pointers-->declarations]>]

## `sizeof` и указатели

[i[Pointers-->with `sizeof`]<]Немного синтаксиса, который может
сбивать с толку и время от времени попадается.

Помните, что `sizeof` работает с _типом_ выражения.

``` {.c}
int *p;

// Выводит размер 'int'
printf("%zu\n", sizeof(int));

// p имеет тип 'int*', значит, выводит размер 'int*'
printf("%zu\n", sizeof p);

// *p имеет тип 'int', значит, выводит размер 'int'
printf("%zu\n", sizeof *p);
```

Иногда в дикой природе можно встретить код с последним вариантом
`sizeof`. Просто помните, что `sizeof` интересуется типом выражения, а
не конкретными переменными в нём.[i[Pointers-->with `sizeof`]>][i[Pointers]>]
